---
layout: layout
title: React
date: 2020-09-25 16:33:56
categories: React
tags: React
---

# React

## react-hooks

> ### useMemo
缓计算存值，仅当依赖想变化时更新，减少不必要的重新计算。不传入依赖则每次都会更新，传入空数组则只更新一次。
```
function App() {
  const [count, setCount] = useState(1);
  const [val, setValue] = useState('');

  function getNum() {
    console.log('===getNum 函数执行了！===')
    return Array.from({ length: count * 100 }, (v, i) => i).reduce((a, b) => a + b)
  }

  const memo = useMemo(getNum, [count]) // 返回的是最后的计算值

  return <div>
    <h4>总和：{memo}</h4>
    <div>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <input value={val} onChange={event => setValue(event.target.value)} />
    </div>
  </div>;
}
```

> ### useCallback
缓存函数，仅当依赖项变化时更新函数，当把返回的缓存函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。
```
function App() {
  const [count, setCount] = useState(1);
  const [val, setValue] = useState('');

  function computed() {
    console.log('===getNum===')
    return Array.from({ length: count * 100 }, (v, i) => i).reduce((a, b) => a + b)
  }

  const getNum = useCallback(computed, [count]) // 返回函数

  return <div>
      <Child getNum={getNum} />
      <div>
          <button onClick={() => setCount(count + 1)}>+1</button>
          <input value={val} onChange={event => setValue(event.target.value)}/>
      </div>
  </div>;
}

const Child = React.memo(function ({ getNum }) {
  return <h4>总和：{getNum()}</h4>
})
```